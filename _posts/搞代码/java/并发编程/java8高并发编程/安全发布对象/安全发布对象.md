## 写在前面
随着编程经验的累加,对多线程的接触也变得多了起来,多线程在我的面前再也不是想以前一样深不可测了.通过学习JUC工具包和JVM模型了解了更多的多线程技巧,这篇文章来总结下ThreadLocal这个神奇的类.

## 名词解释
- YGC(Young Grabage Collection):对新生代堆进行GC,频率比较高,因为大部分对象存货寿命比较短,在新生代里被回收,性能耗费较小.
- FGC(Full Grabage Collection):全堆范围GC,默认对空间使用达到80%(可调整)的时候会触发FGC.以生产环境为例,一半较少会触发FGC,大概一周一次.

## ThreadLocal简介
"水能载舟,亦能覆舟."这句话用来形容ThreadLocal最贴切,ThreadLocal初中是在线程并发时,解决变量共享问题,但是由于过度设计,比如弱引用和哈希碰撞,导致理解难度大,使用成本高,反而成了故障高发点,容易引起内存泄漏、脏数据、共享对象更新等问题。

### 引用类型
对象在对上创建之后所持有的引用其实是一种变量类型，引用之间可以通过赋值构成一条引用链。从GC Roots开始遍历,判断引用是否可达。引用的可达性是判断能否被垃圾回收的基本条件。JVM会根据此自动管理内存的分配与回收，不需要开发工程师干预。但在某些场景下，及时引用可达，也希望根据语义的强弱进行有选择的回收，以保证系统的正常运行。根据引用类型寓意的强弱来决定垃圾回收的阶段，我们可以把引用分为强引用、软引用、弱引用和虚引用四类。后三类引用，本质上可以让开发工程师通过代码方式决定对象的垃圾回收时机。简单介绍下这四种引用：
- 强引用(Strong Reference):最为常见的。如Object object=new Object();这样的变量声明和定义就会产生该对象的强引用。只要对象有强引用指向,并且GC Roots可达,那么Java内存回收时,及时濒临内存好近,也不会回收该对象。
- 软引用(Sort Reference):引用弱与强引用,使用在非必须对象的场景.在即将OOM之前,垃圾回收器会把软引用指向的对象加入回收范围,已获得更多的内存空间.软引用主要是用来缓存服务器中间计算结果以及不需要实时保存的用户数据。
- 弱引用(Weak Reference):弱引用较前两者更弱,也是用来描述非必须对象的.如果弱引用指向的对象只存在弱引用这一条路线,则下次YGC时会被回收.弱引用主要指的是某个易于消失的对象。
- 虚引用(Phantom Reference):是极弱的引用关系,定义完成后,就无法通过该引用获得指向的对象。为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知.虚引用必须引用队列联合使用,当垃圾回收时,如果发现存在虚引用,就会再回收对象内存之前,把这个虚引用加入与之关联的引用队列中。

![](https://ws4.sinaimg.cn/large/006tKfTcly1g1istqj32nj30ey05v749.jpg)

### 弱引用在ThareadLocal中的应用
下面这段代码是WeakReference在ThreadLocal中的使用,之所以使用弱引用是因为ThreadLocalMap可能维护一个非常非常大的Map但是呢,本地线程的资源只有在当前线程中才是有用的,所以我们在使用完本地线程的资源之后需要调用remove方法,来将<div style="color:red">ThreadLocalMap中的key赋值为null这样方便YGC进行垃圾回收.</div>
```
    static class ThreadLocalMap {

        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```

## ThreadLocal副作用
T和热爱的Local有一定的副作用,在使用的时候需要注意避免脏数据和内存泄漏,这两个问题通常是在线程池的线程中使用ThreadLocal引发的,因为线程池有<div style="color:red">线程复用和内存常驻两个特点</div>.

### 脏数据
线程复用会产生脏数据.由于线程池会重用Thread对象,那么与Thread绑定的类的静态属性ThreadLocal变量也会被重用.

### 内存溢出
同样是在多线程的场景下,如果没有及时调用remove()方法也会存在内存溢出的情况.# 安全发布对象--发布与溢出
![](http://ws4.sinaimg.cn/large/006tNc79ly1fyyf0xg3zmj30rt0dbgos.jpg)

![](http://ws4.sinaimg.cn/large/006tNc79ly1fyyf203j2jj30tf0f70wz.jpg)

## 使用饿汉创建对象
使用单例饿汉来创建对象,可以保证线程安全,但是会在启动jvm的时候创建,所以会导致启动时间增加

## 双重检测锁的使用
主要原因是在编译的时候可能对指令进行重排
1. memory=allocate()分配对象的内存空间
2. ctorInstance()初始化对象
3. instance=memory设置instance指向刚分配的内存
![](http://ws1.sinaimg.cn/large/006tNc79ly1fyyf8vevlsj30iq08idit.jpg)

<div style="color:red">使用volatile防止指令重排序</div>
## 使用枚举来创建单例模式
1. JVM可以保证该方法只被调用一次,是绝对的
![](http://ws1.sinaimg.cn/large/006tNc79ly1fyyfhxcrb4j30iu0bfgp5.jpg)

![](http://ws4.sinaimg.cn/large/006tNc79ly1fyyfinpfo3j30rv0egwj0.jpg)