# 死锁
![](https://ws1.sinaimg.cn/large/006tKfTcly1g0joqbxrk2j31fl0u048n.jpg)

## 死锁案例
```java
/**
 * 模拟死锁状态:
 * 1. 创建两个线程并启动他们
 * 2. 线程1 执行需要获取o1锁后在获取o2锁进行执行
 * 3. 线程2 执行需要获取o2锁后在获取o1锁进行执行
 * 4. 两个锁互相钳制造成死锁
 * @author zhengyi
 * @date 2019-02-26 13:17
 **/
@Log4j2
public class DeadLock {

    private static Object o1 = new Object(), o2 = new Object();

    public static void deadLock(int flag) throws InterruptedException {
        if (flag == 1) {
            synchronized (o1) {
                Thread.sleep(500);
                log.info("this is o1 , flag {}", flag);
                synchronized (o2) {
                    log.info("this is o2 , flag {}", flag);
                }
            }
        }
        if (flag == 2) {
            synchronized (o2) {
                Thread.sleep(500);
                log.info("this is o2 , flag {}", flag);
                synchronized (o1) {
                    log.info("this is o1 , flag {}", flag);
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            try {
                deadLock(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Thread thread2 = new Thread(() -> {
            try {
                deadLock(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread1.start();
        thread2.start();
    }
}
```

## 解决死锁的方法
- 通过代码保证加锁需要同时进行
- 添加锁获取的时间限制(使用ReetrantLock)
- 添加死锁检测(一半不用)