# 垃圾收集器与内存分配策略

## 对象已死吗

Java在执行GC(garbage collection)的时候回去判断哪些对象是"活的"哪些对象是"死的".

### 引用计数算法

引用计数算法他的效率很高并且实现起来很容易,但是对于java而言却不是和,在java中会出现循环引用的情况,这时两个对象的引用计数都会保留为1.所以使用引用计数算法无法解决循环引用的情况.

### 可达性分析算法

可达性分析(Reachability Analysis)很多商用语言都是用这种方法判断对象是否存活,

![可达性分析](https://s.niuhp.com/blog/java/jvm/reachability-analysis.png)

在Java语言中,可作为GC Roots的对象包含下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象;
- 方法去中静态属性引用的对象;
- 方法去中常量引用的对象;
- 本地方法栈JNI(java native interface)引用的对象.

### 再谈引用

在JDK1.2之后,对引用进行了细分:

- 强引用(Strong Reference):指的就是代码中普遍存在的"Object obj = new Object()",只要强引用还在垃圾回收就永远不会回收;
- 软引用(Soft Reference):用来描述一些非必须的对象,对于软引用关联着的对象,在系统将要发生内存溢出之前,将会把这些对象列入到二次回收的范围;
- 弱引用(Weak Reference):弱引用的强度比软引用更弱,只能存活到下一次垃圾回收之前,当垃圾回收工作的时候,无论当前内存是否够用,都会讲起列入回收范围;
- 虚引用(Phantom Reference):是最弱的一种引用

### 生存还是死亡

我们知道在java中判断一个对象死亡是通过不可达算法去实现的,但是如果一个对象不可达也不是真的死亡,实际上需要去判断该对象是否执行finalize()方法.**每个对象的finalize()方法只会被调用一次**.

也就是说一个方法其实可以通过finalize()进行自救,但是只能自救一次.

> 这个java的特性是一个**可以忘掉的存在**

```java
/**
 * @author jbzm
 * @date 2019-08-27 18:16
 **/
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("I'm alive");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        // point to the static method that in static method
        SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        //first execution the finalizeEscapeGC save itself
         SAVE_HOOK = new FinalizeEscapeGC();
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("dead");
        }
        //second execution
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("dead");
        }
    }
}
```

### 回收方法区

