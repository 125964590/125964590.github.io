# 走向注解驱动编程

本章是对注解发展史的一个概述,讲解了注解式如何从1.x发展到5.x的过程以及Spring,Spring Boot,Spring Cloud他们三者之间注解的存在关系.主要对一下几个概念进行简单的描述.

- 注解启蒙时代Spring Freamwork 1.x
- 注解驱动过渡时代Spring Framework 2.x
- 注解驱动黄金时代Spring Framework 3.x
- 注解驱动完善时代Spring Framework 4.x
- 注解驱动当下时代Spring Framework 5.x

## Spring配置的变化过程

spring最初的配置方式是通过xml进行实现的,随着发展主键转向java代码+注解.

在spring中大量的声明式配置很繁琐,程序猿在开启一个新的项目时往往需要粘贴大量的配置,在spring boot中通过依赖大于配置的方法将这些冗余的配置优化掉.

## Spring注解的变化

spring早起如果想使用注解需要结合xml文件进行声明.

在之后的版本注解慢慢的过度完善,注解出现注解**派生**的写法,就是定义一个基础注解然后在定义高级注解内部定义基础注解的参数.同时注解的功能逐渐的完善,开始出现**@Conditional**这一类的条件注解以及**@EventListener**

其实我们在讨论注解的时候很多人为是在SpringBoot和SpringCloud中出现的注解,早在Spring的时代就已经定义了雏形.

在5.x时代由于大量的注解涌入,以及**@CompoentScan**的出现导致注解解析的时间过长,从而引入了**@Index**注解去标注索引.

> 如果在5.x中需要使用**@Index**需要单独添加pom依赖
>
> ```xml
> 		<dependency>
> 			<groupId>org.springframework</groupId>
> 			<artifactId>spring-context-indexer</artifactId>
> 			<version>5.0.6.RELEASE</version>
> 		</dependency>
> ```
> 当工程构建的时候会自动的生成**META-INF/spring.components**,换言之,该文件在编译生成时,当Spring应用上下文执行**CompoentScan**时会去扫描**META-INF/spring.components**并且被**CandidateComponentsIndxLoader**读取加载

## Spring核心注解场景分类

按照Spring Framework版本由低到高,重要性由高到低.

### Spring模式注解

|   Spring注解   |     场景说明      | 起始版本 |
| :------------: | :---------------: | :------: |
|  @Repository   | 数据仓库模式注解  |   2.0    |
|   @Component   |   通用组件注解    |   2.5    |
|    @Service    |   服务模式注解    |   2.5    |
|  @Controller   | Web控制器模式注解 |   2.5    |
| @Configuration |  配置类模式注解   |   3.0    |

### 装配注解

|   Spring注解    |               场景说明                | 起始版本 |
| :-------------: | :-----------------------------------: | :------: |
| @ImportResource |          替换XML元素<Import>          |   2.5    |
|     @Import     |      限定@Autowired依赖注入范围       |   2.5    |
| @ComponentScan  | 扫描指定package下标Spring模式注解的类 |   3.1    |

### 依赖注入注解

| Spring注解 |             场景说明              | 起始版本 |
| :--------: | :-------------------------------: | :------: |
| @Autowired | Bean依赖注入,支持多种依赖查找方式 |   2.5    |
| @Qualifier |    细粒度的@Autowired依赖查找     |   2.5    |

| Java注解  | 场景说明                            | 起始版本 |
| :-------- | :---------------------------------- | :------- |
| @Resource | Bean依赖注入,仅支持名称依赖查找方式 | 2,5      |

### Bean定义注解

| Spring注解 | 场景说明                                  | 起始版本 |
| :--------- | ----------------------------------------- | -------- |
| @Bean      | 替换XML元素<bean>                         | 3.0      |
| @DependsOn | 替代XML属性<Bean depends-on="..."/>       | 3.0      |
| @Lazy      | 替代XML属性<bean lazy-ini="true\|false"/> | 3.0      |
| @Primary   | 替换XML元素<bean primary="true\|false"/>  | 3.0      |
| @Role      | 替换XML元素<bean role="..."/>             | 3.1      |
| @Lookup    | 替代XML属性<bean lookup-method="...">     | 4.1      |

 ### Spring条件装配注解

| Spring注解   | 场景说建明     | 起始版本 |
| ------------ | -------------- | -------- |
| @Profile     | 配置化条件装配 | 3.1      |
| @Conditional | 编程条件装配   | 3.1      |

### 配置属性注解

| Spring注解       | 场景说明                       | 起始版本 |
| ---------------- | ------------------------------ | -------- |
| @PropertySource  | 配置属性抽象PropertySource注解 | 3.1      |
| @PropertySources | @PropertySource集合注解        | 4.0      |

### 生命周期回调注解

| Java注解       | 场景说明                                                | 起始版本 |
| -------------- | ------------------------------------------------------- | -------- |
| @PostConstruct | 替换XML元素<bean init-method="..."/>或InitializingBean  | 2.5      |
| @PreDestory    | 替换XML元素<bean destory-method="..."/>或DisposableBean | 2.5      |

### 注解属性注解

| Spring注解 | 场景说明                    | 起始版本 |
| ---------- | --------------------------- | -------- |
| @AliasFor  | 别名注解属性,实现复用的目的 | 4.2      |

### 性能注解

| Spring注解 | 场景说明                        | 起始版本 |
| ---------- | ------------------------------- | -------- |
| @Indexed   | tishengSpring模式注解的扫描效率 | 5.0      |

## Spring注解编程模型

spring注解可以分为以下几种类型:

- 元注解(Meta-Annoations);
- Spring模式注解(Stereotype Annotations);
- Spring组合注解(Composed Annotations);
- Spring注解属性别名和覆盖(Attribute Aliases and Overrides).

理解Spring注解编程模型是深入讨论SpringBoot注解驱动以及自动装配的重要前提.

### 元注解(Meta-Annotions)

元注解就是指能够声明在其他注解上的一个注解,如果一个注解标注在其他注解上,那么他就是元注解.

例如**@Component**就是**@Service**,**@Controller**的元注解

### Spring模式注解(Stereotype Annotations)

"Spring模式注解"用来标注一些由Spring托管的模式组件,其实在Spring中模式注解都是由@Compont"派生"而来的.

#### 1.理解@Component"派生性"

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {

	@AliasFor(annotation = Component.class)
	String value() default "";

}
```

派生性可以理解为在一个注解上声明另一个注解来表示,这种方式说明新的注解会被作为@Component的下级注解来处理,新的注解会包含@Component的一些特性.

#### 2. @Component"派生的原理"

详情见Spring Boot编程思想[^1]

[^1]: SpringBoot编程思想 P166

#### 3. 多层次@Component

详情见Spring Boot编程思想[^2]

[^2]:SpringBoot编程思想 P170

#### 4. 多层次@Component原理

在解析注解的时候会去递归判断该注解下面是否还包含其他的嵌套注解.

掌握Spring模式注解(Stereotype Annotations)以及@Component派生性对深度理解并运用SpringBoot复杂度注解及其重要.

### Spring组合注解

所谓的"组合注解"值得就是某个注解"元标注"一个或者多个其他注解,其目的在于将这些关联的注解行为组合成一个自定义注解.举例说明**@TransactionalService**标注了**@Transactional**和@Service**注解,因此@TransactionalService**组合了这两个注解的语义.

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Transactional
@Service(value = "transactionalService")
public @interface TransactionalService {
}
```

观察**@SpringBootApplication**可以发现它本身就是一个模式注解(Stereotype Annotational)和组合注解(Composed Annotation)

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
}
```

在处理Composed Annotation和Stereotype Annotational相类似,他们的处理逻辑都是封装在**AnnotationAttributesReadingVisitor**中的,本质上调用是**MetadataReaderFactory**所返回的结果,我们通过Asm获取该注解的源信息和value信息,具体看下面的Demo

```java
    public static void main(String[] args) throws IOException {
        // @TransactionalService 标注在当前类 TransactionalServiceAnnotationMetadataBootstrap
        String className = TransactionalServiceAnnotationMetadataBootstrap.class.getName();
        // 构建 MetadataReaderFactory 实例
        MetadataReaderFactory metadataReaderFactory = new CachingMetadataReaderFactory();
        // 读取 @TransactionService MetadataReader 信息
        MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
        // 读取 @TransactionService AnnotationMetadata 信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();

        annotationMetadata.getAnnotationTypes().forEach(annotationType -> {

            Set<String> metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType);

            metaAnnotationTypes.forEach(metaAnnotationType -> {
                System.out.printf("注解 @%s 元标注 @%s\n", annotationType, metaAnnotationType);
            });

        });
    }
```

这个Demo会偷获取注解上的源信息,并且将他们打印出来,由于在方法内部是递归调用的所以打印的时候也会将多层的嵌套全都打印出来

```verilog
注解 @thinking.in.spring.boot.samples.spring5.annotation.TransactionalService 元标注 @org.springframework.transaction.annotation.Transactional
注解 @thinking.in.spring.boot.samples.spring5.annotation.TransactionalService 元标注 @org.springframework.stereotype.Service
注解 @thinking.in.spring.boot.samples.spring5.annotation.TransactionalService 元标注 @org.springframework.stereotype.Component
注解 @thinking.in.spring.boot.samples.spring5.annotation.TransactionalService 元标注 @org.springframework.stereotype.Indexed
```

### Spring注解属性别名和覆盖(Attribute Aliases and Overrdes)

详情间Spring Boot编程思想[^3]

[^3]: SpringBoot编程思想 P198

从Framework4.0开始,**AnnotationMetadata#getMetaAnnotationTypes(String)**方法所能够会去到所有元注解类型集合.再结合**getAnnotationAttributes(String)**方法返回注解所关联的属性信息,以Map结构存储.



