# 60秒延迟测试

## 解决问题

### 测试方法

本地启动 **Eureka**、**Gateway**、**Auth**、**SvcDemo**，开启**AuthorizeGlobalFilter**关闭**ApiStatFilter**

### 问题原因

在请求后端SvcDemo上的服务Post服务并且经过AuthorizeGlobalFilter时产生延迟.

### 问题所在

在过滤器中消费了请求的Body体在写回的时候使用了一个已经被读取过得流,下游filter在获取Body体的时候卡主,**具体卡住源码位置,未确定**

```json
{"code":5000000,"result":"system failed","msg":"Internal Server Error","resultBean":"I/O error while reading input message; nested exception is org.apache.catalina.connector.ClientAbortException: java.net.SocketTimeoutException"}
```



```java
 NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();
                                factory.getByteBufAllocator();

                                ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator(exchange.getRequest()) {
                                    @Override
                                    public Flux<DataBuffer> getBody() {
                                      //此处使用的dataBuffers已经被消费  readIndex=writeIndex
                                        return Flux.just(factory.join(dataBuffers));
                                    }
                                };
```

### 修改方案

可以考虑使用Netty的ByteBuf对数组进行拷贝,由于该字节流方法可以使用对外内存并且使用read与write两个指针实现索引,所以可以多次copy

```java
  NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();
                ByteBuffer byteBuffer = factory.join(dataBuffers).asByteBuffer();
								//此处使用ByteBuf
                ByteBuf directBuf = Unpooled.copiedBuffer(byteBuffer);
                byte[] array = new byte[directBuf.readableBytes()];
                ByteBuf bytes = directBuf.getBytes(directBuf.readerIndex(), array);
                ServerHttpRequest mutatedRequest =
                    new ServerHttpRequestDecorator(exchange.getRequest()) {
                      @Override
                      public Flux<DataBuffer> getBody() {
                        ByteBuf bytes1 = directBuf.getBytes(directBuf.readerIndex(), array);
                        NettyDataBuffer nettyDataBuffer =
                            factory.allocateBuffer(bytes1.readableBytes());
                        nettyDataBuffer.write(bytes1);
                        return Flux.just(nettyDataBuffer);
                      }
                    };
```

## 性能测试

### 使用 ByteBuf

#### 2k大小 body

![image-20191021212321466](https://tva1.sinaimg.cn/large/006y8mN6ly1g865iygb1oj30z10ac77b.jpg)

#### 200k大小 body

![image-20191021212342737](https://tva1.sinaimg.cn/large/006y8mN6ly1g865j5xoc3j310h0anq5z.jpg)

### 使用 DefaultRequest

#### 2k大小 body

![image-20191021213904407](https://tva1.sinaimg.cn/large/006y8mN6ly1g865j05rjwj31090c3adn.jpg)

#### 200k大小 body

![image-20191021213813903](https://tva1.sinaimg.cn/large/006y8mN6ly1g865j2qao7j31030cp77v.jpg)