# 并发
多个线程操作相同的资源,保证线程安全,合理使用资源

## 高并发
服务能同时处理很多请求,提高性能

## Java内存模型(Java Memory Model,JMM)
![](https://ws4.sinaimg.cn/large/006tNc79ly1fyyak0wpr9j31ik0os4qp.jpg)

![](https://ws2.sinaimg.cn/large/006tNc79ly1fyyanr0xphj30tu0q0dwx.jpg)
## 内存模型和硬件之间的关联
![](https://ws2.sinaimg.cn/large/006tNc79ly1fyyaq7tj0dj319a0kue07.jpg)
## Java内存模型抽象结构图
![](https://ws1.sinaimg.cn/large/006tNc79ly1fyyaqs81w3j30v80qk49x.jpg)

## Java内存模型-同步八种操作
- local(锁定):作用域主内存的变量,把一个变量标识为一条线程独占状态
- unlock(解锁):作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定
- read(读取):作用于主内存的变量,把一个变量值从主内存传输到线程的工作内存中,以便随后的load动作使用
- load(载入):作用于工作内存的变量,它把read操作从主内存中得到的变量值放入工作内存的副本中
- use(使用):作用于工作内存的变量,把工作内存中的一个变流量值传递给执行引擎
- assign(赋值):作用于工作内存的变量,他把一个执行引擎接收到赋值给工作内存的变量
- store(存储):作用于工作内存的变量把工作内存中的一个变量值传送到主内存中,执行一遍随后的write操作
- write(写入):作用于主内存的变量,他把store操作从工作内存中的一个变量的值传送到主内存的变量中

## Java内存模型-同步规则
- 如果把一个变量从主内存中赋值到工作内存,就需要按顺序地执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按照顺序地执行store和write操作.但Java内存模型只要求上述操作必须按顺序执行,二没有保证必须是连续执行
- 不允许read和load,store和write操作之一单独出现
- 不允许一个线程丢弃他的最近assign的操作,即变量在工作内存中改变了之后必须同步到主内存中
- 不允许一个线程无原因地(没有发生任何assign操作)吧数据从工作内存通不会主内存中
- 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量.即就是对一个变量实施use和store操作之前,必须限制性过了assign和load操作
- 一个变量在同一时刻只允许一条线成对其进行lock操作,单lock操作可以被同一条线程重复执行多次,多次执行lock后,只有执行相同次数的unlock操作,变量才会被解锁.lock和unlock必须成对出现
- 如果对一个变量执行lock操作,将会清空工作内存中变量的值,在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量实现没有被lock操作锁定,则不允许对他执行unlock操作;月不允许去unlock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前,必须先把变量同步到内存中(执行store和write操作)
![](https://ws2.sinaimg.cn/large/006tNc79ly1fyybbworrsj31om0qqnm8.jpg)

## 并发的优势与风险
![](https://ws2.sinaimg.cn/large/006tNc79ly1fyybkkjm7qj319e0u0nn5.jpg)

# 总结
- CUP多级缓存:缓存一致性,乱序执行优化
- Java内存模型:JMM规定,抽象结构,同步八种操作及规则
- Java并发的优势与风险