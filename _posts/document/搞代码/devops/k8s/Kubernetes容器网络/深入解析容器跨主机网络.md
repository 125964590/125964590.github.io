# 深入解析容器跨主机网络

了解了容器与宿主机之间的通讯机制之后,其实容器与其他宿主机之间的通信模式也就可以理解了, 接下来描述Flannel框架帮助我们完成的通信过程.

## Flanneld UDP模式

![Flannel通信](https://static001.geekbang.org/resource/image/e6/f0/e6827cecb75641d3c8838f2213543cf0.png)

实际上在ETCD中维护了一个路由表,在请求经过宿主机的flanneld的时候根据请求的ip进行判断,寻找对应的路由目标,将请求路由到对应的宿主机,然后再由该宿主机上的flanneld进行接收,转发给下游的容器进行处理.仅在发出IP报的过程中,就需要经过三次用户态与内核态的数据拷贝,如下图所示:

![数据拷贝](https://static001.geekbang.org/resource/image/84/8d/84caa6dc3f9dcdf8b88b56bd2e22138d.png)

可以看到:

第一次: 用户态的容器进程发出IP包经过docker0网桥进入内核态;

第二次:IP包根据路由表进入TUN(flannel0)设备,从而回到用户态的flanneld进程;

第三次:flanneld进行UDP风暴之后重新进入内核态,将UDP包通过宿主机的eth0发出去.

所以说,**在进行系统级编程的时候,有一个非常重要的优化原则,就是要减少用户态到内核态的切换次数,并且把核心的处理逻辑放在内核态进行**.

## Flanneld VXLAN模式

VXLAN,即Virtual Extensible LAN(虚拟可扩展局域网),是Linux内核本身就支持的一种网络虚拟化技术.所以说VXLAN完全可以在内核态上实现上述封装和接触封装的工作.

![vxlan通信原理](https://static001.geekbang.org/resource/image/ce/38/cefe6b99422fba768c53f0093947cd38.png)